{"version":3,"file":"index.min.js","sources":["node_modules/@actualwave/type-checker-simple-reporting/index.js","source/error-reporter.js","source/utils.js","node_modules/@actualwave/has-own/has-own.js","node_modules/@actualwave/type-checker-levels-storage/index.js","source/checker.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable import/prefer-default-export */\n\nconst constructErrorString = (action, name, required, received) => `${action}Error on \"${name}\" instead of \"${required}\" received \"${received}\"`;\n\n/* eslint-disable no-console */\n\nconst ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) => console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nconst ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) => console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\n/* eslint-disable import/prefer-default-export */\n\nconst ThrowErrorReporter = (action, name, requiredTypeString, receivedTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, receivedTypeString));\n};\n\nexports.ConsoleErrorReporter = ConsoleErrorReporter;\nexports.ConsoleWarnReporter = ConsoleWarnReporter;\nexports.ThrowErrorReporter = ThrowErrorReporter;\n//# sourceMappingURL=index.js.map\n","import { ConsoleErrorReporter } from '@actualwave/type-checker-simple-reporting';\r\n\r\nlet errorReporter = ConsoleErrorReporter;\r\n\r\nexport const getErrorReporter = () => errorReporter;\r\n\r\nexport const setErrorReporter = (value) => {\r\n  errorReporter = value;\r\n};\r\n","import { getErrorReporter } from './error-reporter';\n\nexport const MERGE = '(Merge)';\nexport const GET_PROPERTY = '(GetProperty)';\nexport const SET_PROPERTY = '(SetProperty)';\nexport const ARGUMENTS = '(Arguments)';\nexport const RETURN_VALUE = '(ReturnValue)';\n\nexport const checkPrimitiveType = (action, storage, target, names, type) => {\n  if (!type) {\n    return true;\n  }\n\n  const { lastName } = names;\n\n  const storedType = storage.hasType(lastName);\n\n  if (storedType) {\n    if (storedType !== type) {\n      const errorReporter = getErrorReporter();\n\n      errorReporter(action, names.toString(), storedType, type);\n\n      return false;\n    }\n  } else {\n    storage.addFor(lastName, type, target);\n  }\n\n  return true;\n};\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar hasOwn = _interopDefault(require('@actualwave/has-own'));\n\n/**\n * Do not check or report type inconsistency\n */\nconst REPORT_NEVER = 'never';\n/**\n * Report type inconsistency once, i.e. record all types and report new\n */\nconst REPORT_ONCE = 'once';\n/**\n * Report whenever type is inconsistent with initial\n */\nconst REPORT_ALL = 'all';\n\nconst REPORT_KEY = Symbol('type-checkers:report-level');\nconst PROPERTY_REPORT_KEY = Symbol('type-checkers:property-report-level');\n\nlet globalReportingLevel = REPORT_ALL;\n\nconst validateReportingLevel = level => {\n  switch (level) {\n    case REPORT_NEVER:\n    case REPORT_ONCE:\n      return level;\n    default:\n      return REPORT_ALL;\n  }\n};\n\nconst setGlobalReportingLevel = level => {\n  globalReportingLevel = validateReportingLevel(level);\n};\n\nconst getGlobalReportingLevel = () => globalReportingLevel;\n\nconst setTargetGeneralReportingLevel = (target, level) => {\n  if (level) {\n    target[REPORT_KEY] = validateReportingLevel(level);\n  } else {\n    delete target[REPORT_KEY];\n  }\n};\n\nconst setTargetPropertyReportingLevel = (target, perPropertyLevels) => {\n  if (!perPropertyLevels) {\n    delete target[PROPERTY_REPORT_KEY];\n    return;\n  }\n\n  target[PROPERTY_REPORT_KEY] = Object.keys(perPropertyLevels).reduce((levels, prop) => {\n    levels[prop] = validateReportingLevel(perPropertyLevels[prop]);\n    return levels;\n  }, {});\n};\n\nconst setReportingLevel = (target, generalLevel, perPropertyLevels) => {\n  setTargetGeneralReportingLevel(target, generalLevel);\n  setTargetPropertyReportingLevel(target, perPropertyLevels);\n};\n\nconst getTargetReportingLevel = (target, key) => {\n  if (hasOwn(target[PROPERTY_REPORT_KEY], key)) {\n    return target[PROPERTY_REPORT_KEY][key];\n  }\n\n  return target[REPORT_KEY];\n};\n\nconst getReportingLevel = (target, key) => {\n  let level = getTargetReportingLevel(target, key);\n\n  if (!level) {\n    level = getTargetReportingLevel(target.constructor, key);\n  }\n\n  return level || getGlobalReportingLevel();\n};\n\n/**\n *\n * @param {any} key\n * @param {Set} target\n * @param {Set} source\n */\nconst defaultMergeStrategy = (key, target, source) => {\n  if (!source || !target) {\n    return source || target;\n  }\n\n  source.forEach(type => {\n    if (!target.has(type)) {\n      target.add(type);\n    }\n  });\n\n  return target;\n};\n\nclass TypeInfoStorage {\n  constructor() {\n    this.storage = new Map();\n  }\n\n  has(key) {\n    const info = this.storage.get(key);\n\n    return info && info.size;\n  }\n\n  hasType(key, type) {\n    const info = this.storage.get(key);\n\n    return info && info.has(type);\n  }\n\n  /**\n   *\n   * @param {*} key\n   * @param {Function} callback\n   */\n  get(key, callback) {\n    const info = this.storage.get(key);\n\n    if (info) {\n      info.forEach(type => callback(key, type));\n    }\n  }\n\n  /**\n   * Add to type information for specified key.\n   * @param {*} key\n   * @param {*} type\n   * @param {Number} level\n   */\n  add(key, type, level) {\n    if (!type) return;\n\n    switch (level) {\n      case REPORT_NEVER:\n        this.storage.delete(key);\n        break;\n      case REPORT_ONCE:\n        {\n          const types = this.storage.get(key);\n\n          if (types) {\n            if (!types.has(type)) {\n              types.add(type);\n            }\n          } else {\n            this.storage.set(key, new Set([type]));\n          }\n        }\n        break;\n      case REPORT_ALL:\n      default:\n        {\n          const types = this.storage.get(key);\n\n          if (!types || !types.size) {\n            this.storage.set(key, new Set([type]));\n          }\n        }\n        break;\n    }\n  }\n\n  addFor(key, type, target) {\n    this.add(key, type, getReportingLevel(target, key));\n  }\n\n  /**\n   * Replace types information for specific key\n   * @param {*} key\n   * @param {Set} types\n   * @param {Number} level\n   */\n  set(key, types, level) {\n    if (!types || types.size === 0 || level === REPORT_NEVER) {\n      this.storage.delete(key);\n      return;\n    }\n\n    this.storage.set(key, types);\n  }\n\n  /**\n   *\n   * @param {*} key\n   * @param {Set} types\n   * @param {Object} target\n   */\n  setFor(key, types, target) {\n    return this.set(key, types, getReportingLevel(target, key));\n  }\n\n  clone() {\n    const target = new TypeInfoStorage();\n    this.storage.forEach((types, key) => target.set(key, new Set(types)));\n\n    return target;\n  }\n\n  /**\n   * Copy types from current storage to storage passed as first argument.\n   * @param {Map} storage\n   * @param {Object} [target]\n   * @param {Function} [mergeStrategy]\n   */\n  copyTo(storage, target, mergeStrategy = defaultMergeStrategy) {\n    this.storage.forEach((types, key) => {\n      const level = validateReportingLevel(target && getReportingLevel(target, key));\n\n      switch (level) {\n        case REPORT_ALL:\n        case REPORT_ONCE:\n          if (storage.has(key)) {\n            storage.set(key, mergeStrategy(key, storage.get(key), types, level), level);\n          } else {\n            storage.set(key, new Set(types));\n          }\n          break;\n        case REPORT_NEVER:\n        default:\n          break;\n      }\n    });\n\n    return storage;\n  }\n}\n\nconst createTypesStorage = () => new TypeInfoStorage();\n\nexports.REPORT_ALL = REPORT_ALL;\nexports.REPORT_NEVER = REPORT_NEVER;\nexports.REPORT_ONCE = REPORT_ONCE;\nexports.createTypesStorage = createTypesStorage;\nexports.getGlobalReportingLevel = getGlobalReportingLevel;\nexports.setGlobalReportingLevel = setGlobalReportingLevel;\nexports.getReportingLevel = getReportingLevel;\nexports.setReportingLevel = setReportingLevel;\n//# sourceMappingURL=index.js.map\n","/* eslint-disable class-methods-use-this */\nimport { createTypesStorage } from '@actualwave/type-checker-levels-storage';\n\nimport { getErrorReporter } from './error-reporter';\n\nimport {\n  MERGE,\n  ARGUMENTS,\n  GET_PROPERTY,\n  RETURN_VALUE,\n  SET_PROPERTY,\n  checkPrimitiveType,\n} from './utils';\n\nclass PrimitiveTypeChecker {\n  constructor(collectTypesOnInit = true) {\n    this.collectTypesOnInit = collectTypesOnInit;\n  }\n\n  init(target, cachedStorage = null) {\n    let storage;\n\n    if (cachedStorage) {\n      storage = cachedStorage;\n    } else if (this.collectTypesOnInit) {\n      storage = createTypesStorage();\n      Object.keys(target).forEach((key) =>\n        storage.addFor(key, this.getTypeValue(target[key]), target),\n      );\n    }\n\n    return storage;\n  }\n\n  getTypeValue(value) {\n    if (value === undefined) {\n      return '';\n    }\n\n    const type = typeof value;\n\n    if (type === 'object' && value instanceof Array) {\n      return 'array';\n    }\n\n    return type;\n  }\n\n  /**\n   * FIXME add function to @actualwave/type-checker-levels-storage to merge configs\n   * this function should accept storages and merge strategy callback which will\n   * receive type info and decide what should be merged and what not\n   */\n  mergeConfigs(storage, sourceStorage, names) {\n    const errorReporter = getErrorReporter();\n\n    sourceStorage.copyTo(storage, null, (key, target, source) => {\n      const targetFirstValue = target.values().next().value;\n\n      source.forEach((sourceType) => {\n        if (!target.has(sourceType)) {\n          target.add(sourceType);\n\n          if (targetFirstValue) {\n            errorReporter(MERGE, names, targetFirstValue, sourceType);\n          }\n        }\n      });\n\n      return target;\n    });\n  }\n\n  getProperty(target, names, value, storage) {\n    const type = this.getTypeValue(value);\n\n    /**\n     * FIXME this function also stores new type information, so it must receive target\n     * or reporting level to work properly\n     * or callback to store new type value\n     */\n    return checkPrimitiveType(GET_PROPERTY, storage, target, names, type);\n  }\n\n  setProperty(target, names, value, storage) {\n    const type = this.getTypeValue(value);\n\n    return checkPrimitiveType(SET_PROPERTY, storage, target, names, type);\n  }\n\n  arguments(target, names, args, storage) {\n    const { length } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const type = this.getTypeValue(args[index]);\n      const agrValid = checkPrimitiveType(ARGUMENTS, storage, target, names.clone(index), type);\n\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  }\n\n  returnValue(target, names, value, storage) {\n    const type = this.getTypeValue(value);\n\n    const callNames = storage.clone();\n    callNames.appendCustomValue(RETURN_VALUE);\n\n    return checkPrimitiveType(RETURN_VALUE, storage, target, callNames, type);\n  }\n}\n\nexport const createPrimitiveTypeChecker = (collectTypesOnInit) =>\n  new PrimitiveTypeChecker(collectTypesOnInit);\n\nexport default PrimitiveTypeChecker;\n"],"names":["Object","defineProperty","exports","value","constructErrorString","action","name","required","received","requiredTypeString","actualTypeString","console","error","warn","receivedTypeString","Error","errorReporter","ConsoleErrorReporter","getErrorReporter","MERGE","GET_PROPERTY","SET_PROPERTY","ARGUMENTS","RETURN_VALUE","checkPrimitiveType","storage","target","names","type","lastName","storedType","hasType","toString","addFor","hasOwn","has","property","Boolean","call","prototype","hasOwnProperty","ex","require$$0","REPORT_NEVER","REPORT_ONCE","REPORT_ALL","REPORT_KEY","Symbol","PROPERTY_REPORT_KEY","globalReportingLevel","validateReportingLevel","level","getGlobalReportingLevel","getTargetReportingLevel","key","getReportingLevel","constructor","defaultMergeStrategy","source","forEach","add","TypeInfoStorage","[object Object]","this","Map","info","get","size","callback","delete","types","set","Set","mergeStrategy","generalLevel","perPropertyLevels","keys","reduce","levels","prop","setTargetPropertyReportingLevel","PrimitiveTypeChecker","collectTypesOnInit","cachedStorage","createTypesStorage","getTypeValue","undefined","Array","sourceStorage","copyTo","targetFirstValue","values","next","sourceType","args","length","valid","index","clone","callNames","appendCustomValue"],"mappings":"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"}