{"version":3,"file":"primitive-type-checker.min.js","sources":["../../js-type-checkers/node_modules/@actualwave/hasOwn/hasOwn.js","../../js-type-checkers/dist/type-checkers.js","../node_modules/@actualwave/hasOwn/hasOwn.js","../source/utils.js","../source/index.js","../source/minified.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar hasOwn = _interopDefault(require('@actualwave/hasOwn'));\n\nlet defaultTypeChecker = null;\n\nconst getDefaultTypeChecker = () => defaultTypeChecker;\nconst setDefaultTypeChecker = typeChecker => {\n  defaultTypeChecker = typeChecker;\n};\n\nconst PROXY_WRAP_FUNCTION_RETURN_VALUES = 'wrapFunctionReturnValues';\nconst PROXY_WRAP_FUNCTION_ARGUMENTS = 'wrapFunctionArguments';\nconst PROXY_WRAP_SET_PROPERTY_VALUES = 'wrapSetPropertyValues';\nconst PROXY_IGNORE_PROTOTYPE_METHODS = 'ignorePrototypeMethods';\n\nconst getDefaultProxyConfig = () => ({\n  [PROXY_WRAP_FUNCTION_RETURN_VALUES]: true,\n  [PROXY_WRAP_FUNCTION_ARGUMENTS]: false,\n  [PROXY_WRAP_SET_PROPERTY_VALUES]: true,\n  [PROXY_IGNORE_PROTOTYPE_METHODS]: false\n});\n\nconst config = getDefaultProxyConfig();\n\nconst setProxyConfig = newConfig => Object.assign(config, newConfig);\n\nconst getProxyConfig = () => Object.assign({}, config);\n\nconst getProxyConfigValue = (key, info = null) => hasOwn(info, key) ? info[key] : config[key];\n\nconst constructErrorString = (action, name, required, actual) => `${action}Error on \"${name}\" instead of \"${required}\" received \"${actual}\"`;\n\nconst ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) => console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nconst ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) => console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nconst ThrowErrorReporter = (action, name, requiredTypeString, actualTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n};\n\nlet errorReporter = ConsoleErrorReporter;\n\nconst getErrorReporter = () => errorReporter;\n\nconst setErrorReporter = reporter => {\n  errorReporter = reporter;\n};\n\nlet enabled = true;\n\nconst isEnabled = () => enabled;\nconst setEnabled = (value = true) => {\n  enabled = !!value;\n};\n\nconst INFO_KEY = Symbol('type-checkers::info');\n\nconst createChildrenCache = (children = {}) => Object.assign({}, children);\n\nconst createTargetInfo = (checker, config, deep = true, names = [], children = createChildrenCache()) => ({\n  checker,\n  config,\n  deep,\n  names,\n  children\n});\n\nconst getTargetInfo = target => target ? target[INFO_KEY] : undefined;\n\nconst setTargetInfo = (target, info) => {\n  if (target && info) {\n    target[INFO_KEY] = info;\n  }\n};\n\nconst hasTargetInfo = target => !!getTargetInfo(target);\n\nconst getTargetTypeChecker = target => target && target[INFO_KEY] ? target[INFO_KEY].checker : undefined;\n\nconst getTargetTypeCheckerConfig = target => {\n  if (!target || !target[INFO_KEY]) {\n    return undefined;\n  }\n\n  return target[INFO_KEY].config;\n};\n\nconst mergeChildrenCache = (targetCache, sourceCache) => {\n  for (const name in sourceCache) {\n    if (hasOwn(targetCache, name)) {\n      targetCache[name] = mergeTargetInfo(targetCache[name], sourceCache[name]);\n    } else {\n      targetCache[name] = sourceCache[name];\n    }\n  }\n\n  return targetCache;\n};\n\nconst storeChildInfo = (cache, name, childInfo) => {\n  delete cache[name];\n\n  if (childInfo) {\n    cache[name] = childInfo;\n  }\n};\n\nconst storeChildInfoFrom = (cache, name, child) => {\n  storeChildInfo(cache, name, getTargetInfo(child));\n};\n\nconst getChildInfo = (cache, name) => cache[name];\n\nconst mergeTargetInfo = (targetInfo, sourceInfo) => {\n  const { deep, checker, children, config, names } = targetInfo;\n\n  if (checker === sourceInfo.checker) {\n    targetInfo.deep = deep || sourceInfo.deep;\n    targetInfo.children = mergeChildrenCache(children, sourceInfo.children);\n    targetInfo.config = checker.mergeConfigs(config, sourceInfo.config, names);\n  } else {\n    console.error('TypeChecked objects can be merged only if using exactly same instance of type checker.');\n  }\n\n  return targetInfo;\n};\n\nconst TARGET_KEY = Symbol('type-checkers::target');\n\nconst getOriginalTarget = target => {\n  return target[TARGET_KEY] || target;\n};\n\nconst validTypes = {\n  object: true,\n  function: true\n};\n\nconst isValidTarget = target => Boolean(target && validTypes[typeof target]);\nconst isTypeChecked = target => Boolean(target && target[TARGET_KEY]);\n\nconst getTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, children, names, checker } = info;\n\n  if (deep || value instanceof Function) {\n    const childInfo = getChildInfo(children, property);\n\n    if (childInfo) {\n      value = createFn(value, { info: childInfo });\n    } else {\n      value = createFn(value, { deep, names: [...names, property], checker });\n      storeChildInfoFrom(children, property, value);\n    }\n  }\n\n  return value;\n};\n\nconst isIgnoredProperty = (target, info, property, value) => {\n  if (value instanceof Function && !hasOwn(target, property) && getProxyConfigValue(PROXY_IGNORE_PROTOTYPE_METHODS, info)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getProperty = createFn => (target, property) => {\n  const value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n    /*\n    target[TARGET_KEY] is a virtual property accessing which indicates\n    if object is wrapped with type checked proxy or not.\n    */\n  } else if (property === TARGET_KEY) {\n    return target;\n  }\n\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.getProperty) {\n    checker.getProperty(target, property, value, config, names);\n  }\n\n  if (!isValidTarget(value) || isTypeChecked(value) || isIgnoredProperty(target, info, property, value)) {\n    return value;\n  }\n\n  return getTargetProperty(createFn, target, property, value);\n};\n\nconst setNonTargetProperty = (target, property, value) => {\n  if (property === INFO_KEY) {\n    let info = getTargetInfo(target);\n    if (info && value && info !== value) {\n      info = mergeTargetInfo(info, value);\n    } else {\n      info = value;\n    }\n\n    target[property] = info;\n    return true;\n  } else if (!isValidTarget(value)) {\n    const { names, config, checker } = getTargetInfo(target);\n\n    if (checker.setProperty) {\n      checker.setProperty(target, property, value, config, names);\n    }\n\n    target[property] = value;\n    return true;\n  }\n\n  return false;\n};\n\nconst setTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, names, checker, config, children } = info;\n\n  if (checker.setProperty) {\n    checker.setProperty(target, property, value, config, names);\n  }\n\n  if (getProxyConfigValue(PROXY_WRAP_SET_PROPERTY_VALUES, info)) {\n    if (!isTypeChecked(value)) {\n      const childInfo = getChildInfo(children, property);\n\n      if (childInfo) {\n        value = createFn(value, { info: childInfo });\n      } else {\n        value = createFn(value, { deep, names: [...names, property], checker });\n      }\n    }\n\n    storeChildInfoFrom(children, property, value);\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst setProperty = createFn => (target, property, value) => {\n  if (property === TARGET_KEY) {\n    throw new Error(`\"${TARGET_KEY}\" is a virtual property and cannot be set`);\n  }\n\n  return setNonTargetProperty(target, property, value) || setTargetProperty(createFn, target, property, value);\n};\n\nconst getTypeCheckedChild = (createFn, info, name, value) => {\n  if (!isValidTarget(value)) {\n    return value;\n  }\n\n  let result = value;\n\n  if (!isTypeChecked(value)) {\n    const { children } = info;\n    const childInfo = getChildInfo(children, name);\n\n    if (childInfo) {\n      result = createFn(value, { info: childInfo });\n    } else {\n      const { deep, names, checker } = info;\n      result = createFn(value, { deep, names: [...names, name], checker });\n      storeChildInfoFrom(children, name, result);\n    }\n  }\n\n  return result;\n};\n\nconst getTargetArguments = (createFn, target, argumentsList) => {\n  const info = getTargetInfo(target);\n\n  if (getProxyConfigValue(PROXY_WRAP_FUNCTION_ARGUMENTS, info)) {\n    const { length } = argumentsList;\n    // FIXME cache arguments info objects as children\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = getTypeCheckedChild(createFn, info, String(index), argumentsList[index]);\n    }\n  }\n\n  return argumentsList;\n};\n\nconst callFunction = createFn => (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(target, thisArg, argumentsList, config, names);\n  }\n\n  argumentsList = getTargetArguments(createFn, target, argumentsList);\n\n  let result = target.apply(thisArg, argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(target, thisArg, result, config, names);\n  }\n\n  if (getProxyConfigValue(PROXY_WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(createFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nlet getProperty$1;\nlet setProperty$1;\nlet callFunction$1;\n\nconst objectProxy = target => new Proxy(target, {\n  get: getProperty$1,\n  set: setProperty$1\n});\n\nconst functionProxy = target => new Proxy(target, {\n  get: getProperty$1,\n  set: setProperty$1,\n  apply: callFunction$1,\n  construct: callFunction$1\n});\n\nconst wrapWithProxy = target => {\n  if (target instanceof Function) {\n    return functionProxy(target);\n  }\n\n  return objectProxy(target);\n};\n\nconst createInfoFromOptions = (target, {\n  deep = true,\n  names = [],\n  config = null,\n  children = null,\n  checker = getDefaultTypeChecker(),\n  info = null // exclusive option, if set other options being ignored\n} = {}) => info || createTargetInfo(checker, checker.init(target, getErrorReporter(), config), deep, names, createChildrenCache(children));\n\nconst create = (target, options) => {\n  if (!isValidTarget(target) || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  setTargetInfo(target, createInfoFromOptions(target, options));\n\n  return wrapWithProxy(target);\n};\n\ngetProperty$1 = getProperty(create);\nsetProperty$1 = setProperty(create);\ncallFunction$1 = callFunction(create);\n\nconst deepInitializer = (target, options) => {\n  const info = createInfoFromOptions(target, options);\n  const { deep, names, checker, config, children } = info;\n\n  Object.keys(target).forEach(name => {\n    const value = target[name];\n\n    checker.getProperty(target, name, value, config, names);\n\n    // skip functions/methods since we get info about them only when being executed\n    if (typeof value === 'object') {\n      let childInfo = getChildInfo(children, name);\n\n      if (childInfo) {\n        deepInitializer(value, { info: childInfo });\n      } else {\n        childInfo = deepInitializer(value, { deep, names: [...names, name], checker });\n        storeChildInfo(children, name, childInfo);\n      }\n    }\n  });\n\n  setTargetInfo(target, info);\n\n  return info;\n};\n\nconst createDeep = (target, options) => {\n  if (!target || typeof target !== 'object' || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  deepInitializer(target, options);\n\n  return wrapWithProxy(target);\n};\n\nconst objectMerge = (options, ...sources) => {\n  let target = {};\n\n  if (isEnabled()) {\n    if (!options) {\n      options = {\n        info: getTargetInfo(sources.find(item => hasTargetInfo(item))),\n        deep: false\n      };\n    }\n\n    target = create(target, options);\n  }\n\n  return Object.assign(target, ...sources);\n};\n\n// TODO if enabled, replaces original value with type checked\nconst properties = (target, options = undefined, ...names) => {\n  if (!isEnabled()) {\n    return target;\n  }\n\n  if (!isValidTarget(target)) {\n    throw new Error('Target must be a valid object.');\n  }\n\n  if (Object.isFrozen(target) || Object.isSealed(target)) {\n    throw new Error('Target object should not be sealed or frozen.');\n  }\n\n  if (!names.length) {\n    // Symbols and non-enumerables must be explicitly specified\n    names = Object.keys(target);\n  }\n\n  const { length } = names;\n  for (let index = 0; index < length; index += 1) {\n    const name = names[index];\n    const { writable, get, set } = Object.getOwnPropertyDescriptor(target, name);\n\n    // Prohibit applying to properties with accessor/mutator pair?\n    if (get && set || writable) {\n      const value = target[name];\n\n      if (isValidTarget(value) && !isTypeChecked(value)) {\n        target[name] = create(value, options);\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.getDefaultTypeChecker = getDefaultTypeChecker;\nexports.setDefaultTypeChecker = setDefaultTypeChecker;\nexports.PROXY_WRAP_FUNCTION_RETURN_VALUES = PROXY_WRAP_FUNCTION_RETURN_VALUES;\nexports.PROXY_WRAP_FUNCTION_ARGUMENTS = PROXY_WRAP_FUNCTION_ARGUMENTS;\nexports.PROXY_WRAP_SET_PROPERTY_VALUES = PROXY_WRAP_SET_PROPERTY_VALUES;\nexports.PROXY_IGNORE_PROTOTYPE_METHODS = PROXY_IGNORE_PROTOTYPE_METHODS;\nexports.getDefaultProxyConfig = getDefaultProxyConfig;\nexports.setProxyConfig = setProxyConfig;\nexports.getProxyConfig = getProxyConfig;\nexports.create = create;\nexports.createDeep = createDeep;\nexports.ConsoleErrorReporter = ConsoleErrorReporter;\nexports.ConsoleWarnReporter = ConsoleWarnReporter;\nexports.ThrowErrorReporter = ThrowErrorReporter;\nexports.getErrorReporter = getErrorReporter;\nexports.setErrorReporter = setErrorReporter;\nexports.isEnabled = isEnabled;\nexports.setEnabled = setEnabled;\nexports.getTargetInfo = getTargetInfo;\nexports.setTargetInfo = setTargetInfo;\nexports.hasTargetInfo = hasTargetInfo;\nexports.getTargetTypeChecker = getTargetTypeChecker;\nexports.getTargetTypeCheckerConfig = getTargetTypeCheckerConfig;\nexports.mergeTargetInfo = mergeTargetInfo;\nexports.getOriginalTarget = getOriginalTarget;\nexports.merge = objectMerge;\nexports.properties = properties;\nexports.isTypeChecked = isTypeChecked;\nexports.isValidTarget = isValidTarget;\nexports.default = create;\n//# sourceMappingURL=type-checkers.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","export const MERGE = '(Merge)';\nexport const GET_PROPERTY = '(GetProperty)';\nexport const SET_PROPERTY = '(SetProperty)';\nexport const ARGUMENTS = '(Arguments)';\nexport const RETURN_VALUE = '(ReturnValue)';\n\nexport function AsIs(value) {\n  if (this instanceof AsIs) {\n    this.value = value;\n  } else {\n    return new AsIs(value);\n  }\n}\n\nfunction asIs() {\n  return this.value;\n}\n\nAsIs.prototype.toString = asIs;\nAsIs.prototype.valueOf = asIs;\nAsIs.prototype[Symbol.toPrimitive] = asIs;\n\nexport const buildPath = (sequence) =>\n  sequence.reduce((str, name) => {\n    if (name instanceof AsIs) {\n      return `${str}${name}`;\n    } else if (String(parseInt(name, 10)) === name) {\n      return `${str}[${name}]`;\n    } else if (/^[a-z][\\w$]*$/i.test(name)) {\n      return str ? `${str}.${name}` : name;\n    }\n\n    return `${str}[\"${name}\"]`;\n  }, '');\n\nexport const checkPrimitiveType = (\n  action,\n  types,\n  name,\n  type,\n  errorReporter,\n  sequence,\n) => {\n  if (!type) {\n    return true;\n  }\n\n  const storedType = types[name];\n\n  if (storedType) {\n    if (storedType !== type) {\n      errorReporter(action, buildPath([...sequence, name]), storedType, type);\n\n      return false;\n    }\n  } else {\n    types[name] = type;\n  }\n\n  return true;\n};\n","import hasOwn from '@actualwave/hasOwn';\n\nimport {\n  MERGE,\n  ARGUMENTS,\n  GET_PROPERTY,\n  RETURN_VALUE,\n  SET_PROPERTY,\n  buildPath,\n  AsIs,\n  checkPrimitiveType,\n} from './utils';\n\nconst mergeConfigs = ({ types, errorReporter }, source, names = []) => {\n  const sourceTypes = source.types;\n\n  for (const name in sourceTypes) {\n    if (hasOwn(sourceTypes, name)) {\n      const sourceType = sourceTypes[name];\n      const targetType = types[name];\n\n      if (sourceType && targetType && targetType !== sourceType) {\n        errorReporter(\n          MERGE,\n          buildPath([...names, name]),\n          targetType,\n          sourceType,\n        );\n      } else {\n        types[name] = sourceType;\n      }\n    }\n  }\n\n  return { types, errorReporter };\n};\n\nconst getTypeString = (value) => {\n  if (value === undefined) {\n    return '';\n  } else if (value instanceof Array) {\n    return 'array';\n  }\n\n  return typeof value;\n};\n\nconst propertyCheckerFactory = (action) => {\n  function checkValueType(target, name, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(\n      action,\n      types,\n      name,\n      type,\n      errorReporter,\n      sequence,\n    );\n  }\n\n  return checkValueType;\n};\n\nconst getPropertyChecker = propertyCheckerFactory(GET_PROPERTY);\nconst setPropertyChecker = propertyCheckerFactory(SET_PROPERTY);\n\nclass PrimitiveTypeChecker {\n  collectTypesOnInit = true;\n  getTypeString = getTypeString;\n  mergeConfigs = mergeConfigs;\n\n  init(target, errorReporter, cachedTypes = null) {\n    let types = {};\n\n    if (cachedTypes) {\n      types = cachedTypes;\n    } else if (this.collectTypesOnInit) {\n      Object.keys(target).forEach((key) => {\n        types[key] = getTypeString(target[key]);\n      });\n    }\n\n    return {\n      types,\n      errorReporter,\n    };\n  }\n\n  getProperty(target, name, value, config, sequence) {\n    return getPropertyChecker.call(this, target, name, value, config, sequence);\n  }\n\n  setProperty(target, name, value, config, sequence) {\n    return setPropertyChecker.call(this, target, name, value, config, sequence);\n  }\n\n  arguments(target, thisArg, args, config, sequence) {\n    const { types, errorReporter } = config;\n\n    const { length } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const type = this.getTypeString(args[index]);\n      const agrValid = checkPrimitiveType(\n        ARGUMENTS,\n        types,\n        String(index),\n        type,\n        errorReporter,\n        sequence,\n      );\n\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  }\n\n  returnValue(target, thisArg, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(\n      RETURN_VALUE,\n      types,\n      AsIs(RETURN_VALUE),\n      type,\n      errorReporter,\n      sequence,\n    );\n  }\n}\n\nexport {\n  MERGE,\n  ARGUMENTS,\n  GET_PROPERTY,\n  RETURN_VALUE,\n  SET_PROPERTY,\n  buildPath,\n  AsIs,\n  checkPrimitiveType,\n  mergeConfigs,\n  getTypeString,\n  propertyCheckerFactory,\n  PrimitiveTypeChecker,\n};\n\nexport default PrimitiveTypeChecker;\n","/* eslint-disable import/no-extraneous-dependencies */\nconst typeCheckers = require('@actualwave/type-checkers');\nconst primitive = require('./index');\n\ntypeCheckers.setDefaultTypeChecker(new primitive.PrimitiveTypeChecker());\n\nObject.assign(exports, primitive, typeCheckers);\n"],"names":["Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","ex","require","defaultTypeChecker","getDefaultTypeChecker","getDefaultProxyConfig","config","getProxyConfigValue","key","info","constructErrorString","action","name","required","actual","ConsoleErrorReporter","requiredTypeString","actualTypeString","console","error","errorReporter","getErrorReporter","enabled","isEnabled","INFO_KEY","Symbol","createChildrenCache","children","assign","getTargetInfo","undefined","setTargetInfo","hasTargetInfo","storeChildInfo","cache","childInfo","storeChildInfoFrom","child","getChildInfo","mergeTargetInfo","targetInfo","sourceInfo","deep","checker","names","targetCache","sourceCache","mergeChildrenCache","mergeConfigs","TARGET_KEY","validTypes","isValidTarget","isTypeChecked","getTypeCheckedChild","createFn","result","getProperty$1","setProperty$1","callFunction$1","wrapWithProxy","Function","Proxy","functionProxy","objectProxy","createInfoFromOptions","createTargetInfo","init","create","options","getProperty","isIgnoredProperty","getTargetProperty","Error","setProperty","setNonTargetProperty","setTargetProperty","thisArg","argumentsList","arguments","length","index","String","getTargetArguments","apply","returnValue","callFunction","deepInitializer","keys","forEach","typeChecker","newConfig","warn","reporter","sources","find","item","isFrozen","isSealed","writable","get","set","getOwnPropertyDescriptor","ARGUMENTS","RETURN_VALUE","AsIs","this","asIs","toString","valueOf","toPrimitive","buildPath","sequence","reduce","str","parseInt","test","checkPrimitiveType","types","type","storedType","source","sourceTypes","sourceType","targetType","getTypeString","Array","propertyCheckerFactory","getPropertyChecker","setPropertyChecker","PrimitiveTypeChecker","collectTypesOnInit","cachedTypes","args","valid","typeCheckers","setDefaultTypeChecker","primitive"],"mappings":"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"}