{"version":3,"file":"primitive-type-checker.min.js","sources":["../node_modules/@actualwave/hasOwn/hasOwn.js","../source/utils.js","../source/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","export const MERGE = '(Merge)';\nexport const GET_PROPERTY = '(GetProperty)';\nexport const SET_PROPERTY = '(SetProperty)';\nexport const ARGUMENTS = '(Arguments)';\nexport const RETURN_VALUE = '(ReturnValue)';\n\nexport function AsIs(value) {\n  if (this instanceof AsIs) {\n    this.value = value;\n  } else {\n    return new AsIs(value);\n  }\n}\n\nfunction asIs() {\n  return this.value;\n}\n\nAsIs.prototype.toString = asIs;\nAsIs.prototype.valueOf = asIs;\nAsIs.prototype[Symbol.toPrimitive] = asIs;\n\nexport const buildPath = (sequence) =>\n  sequence.reduce((str, name) => {\n    if (name instanceof AsIs) {\n      return `${str}${name}`;\n    } else if (String(parseInt(name, 10)) === name) {\n      return `${str}[${name}]`;\n    } else if (/^[a-z][\\w$]*$/i.test(name)) {\n      return str ? `${str}.${name}` : name;\n    }\n\n    return `${str}[\"${name}\"]`;\n  }, '');\n\nexport const checkPrimitiveType = (\n  action,\n  types,\n  name,\n  type,\n  errorReporter,\n  sequence,\n) => {\n  if (!type) {\n    return true;\n  }\n\n  const storedType = types[name];\n\n  if (storedType) {\n    if (storedType !== type) {\n      errorReporter(action, buildPath([...sequence, name]), storedType, type);\n\n      return false;\n    }\n  } else {\n    types[name] = type;\n  }\n\n  return true;\n};\n","import hasOwn from '@actualwave/hasOwn';\n\nimport {\n  MERGE,\n  ARGUMENTS,\n  GET_PROPERTY,\n  RETURN_VALUE,\n  SET_PROPERTY,\n  buildPath,\n  AsIs,\n  checkPrimitiveType,\n} from './utils';\n\nconst mergeConfigs = ({ types, errorReporter }, source, names = []) => {\n  const sourceTypes = source.types;\n\n  for (const name in sourceTypes) {\n    if (hasOwn(sourceTypes, name)) {\n      const sourceType = sourceTypes[name];\n      const targetType = types[name];\n\n      if (sourceType && targetType && targetType !== sourceType) {\n        errorReporter(\n          MERGE,\n          buildPath([...names, name]),\n          targetType,\n          sourceType,\n        );\n      } else {\n        types[name] = sourceType;\n      }\n    }\n  }\n\n  return { types, errorReporter };\n};\n\nconst getTypeString = (value) => {\n  if (value === undefined) {\n    return '';\n  } else if (value instanceof Array) {\n    return 'array';\n  }\n\n  return typeof value;\n};\n\nconst propertyCheckerFactory = (action) => {\n  function checkValueType(target, name, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(\n      action,\n      types,\n      name,\n      type,\n      errorReporter,\n      sequence,\n    );\n  }\n\n  return checkValueType;\n};\n\nconst getPropertyChecker = propertyCheckerFactory(GET_PROPERTY);\nconst setPropertyChecker = propertyCheckerFactory(SET_PROPERTY);\n\nclass PrimitiveTypeChecker {\n  collectTypesOnInit = true;\n  getTypeString = getTypeString;\n  mergeConfigs = mergeConfigs;\n\n  init(target, errorReporter, cachedTypes = null) {\n    let types = {};\n\n    if (cachedTypes) {\n      types = cachedTypes;\n    } else if (this.collectTypesOnInit) {\n      Object.keys(target).forEach((key) => {\n        types[key] = getTypeString(target[key]);\n      });\n    }\n\n    return {\n      types,\n      errorReporter,\n    };\n  }\n\n  getProperty(target, name, value, config, sequence) {\n    return getPropertyChecker.call(this, target, name, value, config, sequence);\n  }\n\n  setProperty(target, name, value, config, sequence) {\n    return setPropertyChecker.call(this, target, name, value, config, sequence);\n  }\n\n  arguments(target, thisArg, args, config, sequence) {\n    const { types, errorReporter } = config;\n\n    const { length } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const type = this.getTypeString(args[index]);\n      const agrValid = checkPrimitiveType(\n        ARGUMENTS,\n        types,\n        String(index),\n        type,\n        errorReporter,\n        sequence,\n      );\n\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  }\n\n  returnValue(target, thisArg, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(\n      RETURN_VALUE,\n      types,\n      AsIs(RETURN_VALUE),\n      type,\n      errorReporter,\n      sequence,\n    );\n  }\n}\n\nexport {\n  MERGE,\n  ARGUMENTS,\n  GET_PROPERTY,\n  RETURN_VALUE,\n  SET_PROPERTY,\n  buildPath,\n  AsIs,\n  checkPrimitiveType,\n  mergeConfigs,\n  getTypeString,\n  propertyCheckerFactory,\n};\n\nexport default PrimitiveTypeChecker;\n"],"names":["Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","ARGUMENTS","RETURN_VALUE","AsIs","this","asIs","toString","valueOf","Symbol","toPrimitive","buildPath","sequence","reduce","str","name","String","parseInt","test","checkPrimitiveType","action","types","type","errorReporter","storedType","mergeConfigs","source","names","sourceTypes","sourceType","targetType","getTypeString","undefined","Array","propertyCheckerFactory","config","getPropertyChecker","setPropertyChecker","collectTypesOnInit","cachedTypes","keys","forEach","key","thisArg","args","length","valid","index"],"mappings":"gOAEAA,OAAOC,eAAeC,EAAS,cAAgBC,OAAO,IAEtD,MAAMC,EAAS,CACZC,GACD,CAACC,EAAQC,IACTC,QAAQF,GAAUD,EAAII,KAAKH,EAAQC,IAHtB,CAIbP,OAAOU,UAAUC,gBAEnBT,SAAiBE,EACjBF,UAAkBE,4ICRLQ,EAAY,cACZC,EAAe,gBAErB,SAASC,EAAKX,QACfY,gBAAgBD,UAGX,IAAIA,EAAKX,QAFXA,MAAQA,EAMjB,SAASa,WACAD,KAAKZ,MAGdW,EAAKJ,UAAUO,SAAWD,EAC1BF,EAAKJ,UAAUQ,QAAUF,EACzBF,EAAKJ,UAAUS,OAAOC,aAAeJ,QAExBK,EAAaC,GACxBA,EAASC,OAAO,CAACC,EAAKC,IAChBA,aAAgBX,KACRU,IAAMC,IACPC,OAAOC,SAASF,EAAM,OAASA,KAC9BD,KAAOC,KACR,iBAAiBG,KAAKH,GACxBD,KAASA,KAAOC,IAASA,KAGxBD,MAAQC,MACjB,IAEQI,EAAqB,CAChCC,EACAC,EACAN,EACAO,EACAC,EACAX,SAEKU,SACI,QAGHE,EAAaH,EAAMN,MAErBS,MACEA,IAAeF,WACHF,EAAQT,MAAcC,EAAUG,IAAQS,EAAYF,IAE3D,SAGHP,GAAQO,SAGT,GC9CHG,EAAe,EAAGJ,MAAAA,EAAOE,cAAAA,GAAiBG,EAAQC,cAChDC,EAAcF,EAAOL,UAEtB,MAAMN,KAAQa,KACblC,EAAOkC,EAAab,GAAO,OACvBc,EAAaD,EAAYb,GACzBe,EAAaT,EAAMN,GAErBc,GAAcC,GAAcA,IAAeD,IDrBhC,UCwBXlB,MAAcgB,EAAOZ,IACrBe,EACAD,KAGId,GAAQc,SAKXR,MAAAA,EAAOE,cAAAA,IAGZQ,EAAiBtC,QACPuC,IAAVvC,EACK,GACEA,aAAiBwC,MACnB,eAGKxC,EAGVyC,EAA0Bd,oBACNxB,EAAQmB,EAAMtB,EAAO0C,EAAQvB,SAC7CS,MAAEA,EAAFE,cAASA,GAAkBY,EAC3Bb,EAAOjB,KAAK0B,cAActC,UAEzB0B,EACLC,EACAC,EACAN,EACAO,EACAC,EACAX,KAOAwB,EAAqBF,EDhEC,iBCiEtBG,EAAqBH,EDhEC,yBAFP,uCACO,gDACA,+JCmE1BI,oBAAqB,OACrBP,cAAgBA,OAChBN,aAAeA,OAEV7B,EAAQ2B,EAAegB,EAAc,UACpClB,YAEAkB,IACMA,EACClC,KAAKiC,2BACPE,KAAK5C,GAAQ6C,QAASC,MACrBA,GAAOX,EAAcnC,EAAO8C,4CAU5B9C,EAAQmB,EAAMtB,EAAO0C,EAAQvB,UAChCwB,EAAmBrC,KAAKM,KAAMT,EAAQmB,EAAMtB,EAAO0C,EAAQvB,eAGxDhB,EAAQmB,EAAMtB,EAAO0C,EAAQvB,UAChCyB,EAAmBtC,KAAKM,KAAMT,EAAQmB,EAAMtB,EAAO0C,EAAQvB,aAG1DhB,EAAQ+C,EAASC,EAAMT,EAAQvB,SACjCS,MAAEA,EAAFE,cAASA,GAAkBY,GAE3BU,OAAEA,GAAWD,MACfE,GAAQ,MAEP,IAAIC,EAAQ,EAAGA,EAAQF,EAAQE,IAAS,OACrCzB,EAAOjB,KAAK0B,cAAca,EAAKG,MACpB5B,EACfjB,EACAmB,EACAL,OAAO+B,GACPzB,EACAC,EACAX,IAGkBkC,SAGfA,cAGGlD,EAAQ+C,EAASlD,EAAO0C,EAAQvB,SACpCS,MAAEA,EAAFE,cAASA,GAAkBY,EAC3Bb,EAAOjB,KAAK0B,cAActC,UAEzB0B,EACLhB,EACAkB,EACAjB,EAAKD,GACLmB,EACAC,EACAX"}