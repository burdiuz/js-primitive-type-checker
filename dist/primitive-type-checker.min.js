!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.PrimitiveTypeChecker={})}(this,function(e){"use strict";function r(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function t(e,r){return e(r={exports:{}},r.exports),r.exports}var n=t(function(e,r){Object.defineProperty(r,"__esModule",{value:!0});const t=(e=>(r,t)=>Boolean(r&&e.call(r,t)))(Object.prototype.hasOwnProperty);r.hasOwn=t,r.default=t}),o=r(n),c=(n.hasOwn,t(function(e,r){Object.defineProperty(r,"__esModule",{value:!0});var t,o=(t=n)&&"object"==typeof t&&"default"in t?t.default:t;let c=null;const s=()=>c,i=()=>({wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0,ignorePrototypeMethods:!1}),a={wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0,ignorePrototypeMethods:!1},p=(e,r=null)=>o(r,e)?r[e]:a[e],u=(e,r,t,n)=>`${e}Error on "${r}" instead of "${t}" received "${n}"`,l=(e,r,t,n)=>console.error(u(e,r,t,n));let f=l;const g=()=>f;let y=!0;const h=()=>y,d=Symbol("type-checkers::info"),P=(e={})=>Object.assign({},e),T=e=>e?e[d]:void 0,R=(e,r)=>{e&&r&&(e[d]=r)},O=e=>!!T(e),E=e=>`@${e}`,m=(e,r,t)=>{const n=E(r);delete e[n],t&&(e[n]=t)},k=(e,r,t)=>{m(e,r,T(t))},_=(e,r)=>e[E(r)],b=(e,r)=>{const{deep:t,checker:n,children:c,config:s,names:i}=e;return n===r.checker?(e.deep=t||r.deep,e.children=((e,r)=>{for(const t in r)o(e,t)?e[t]=b(e[t],r[t]):e[t]=r[t];return e})(c,r.children),e.config=n.mergeConfigs(s,r.config,i)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),e},C=Symbol("type-checkers::target"),w={object:!0,function:!0},S=e=>Boolean(e&&w[typeof e]),j=e=>Boolean(e&&e[C]),v=(e,r,t,n)=>{if(!S(n))return n;let o=n;if(!j(n)){const{children:c}=r,s=_(c,t);if(s)o=e(n,{info:s});else{const{deep:s,names:i,checker:a}=r;o=e(n,{deep:s,names:[...i,t],checker:a}),k(c,t,o)}}return o};let A,V,I;const F=e=>e instanceof Function?(e=>new Proxy(e,{get:A,set:V,apply:I,construct:I}))(e):(e=>new Proxy(e,{get:A,set:V}))(e),M=(e,{deep:r=!0,names:t=[],config:n=null,children:o=null,checker:c=s(),info:i=null}={})=>i||((e,r,t=!0,n=[],o=P())=>({checker:e,config:r,deep:t,names:n,children:o}))(c,c.init(e,g(),n),r,t,P(o)),N=(e,r)=>S(e)&&h()&&!j(e)?(R(e,M(e,r)),F(e)):e;A=(e=>(r,t)=>{const n=r[t];if(t===d)return n;if(t===C)return r;const c=T(r),{names:s,config:i,checker:a}=c;return a.getProperty&&a.getProperty(r,t,n,i,s),!S(n)||j(n)||((e,r,t,n)=>!!(n instanceof Function&&!o(e,t)&&p("ignorePrototypeMethods",r)))(r,c,t,n)?n:((e,r,t,n)=>{const o=T(r),{deep:c,children:s,names:i,checker:a}=o;if(c||n instanceof Function){const r=_(s,t);r?n=e(n,{info:r}):(n=e(n,{deep:c,names:[...i,t],checker:a}),k(s,t,n))}return n})(e,r,t,n)})(N),V=(e=>(r,t,n)=>{if(t===C)throw new Error(`"${C}" is a virtual property and cannot be set`);return((e,r,t)=>{if(r===d){let n=T(e);return n=n&&t&&n!==t?b(n,t):t,e[r]=n,!0}if(!S(t)){const{names:n,config:o,checker:c}=T(e);return c.setProperty&&c.setProperty(e,r,t,o,n),e[r]=t,!0}return!1})(r,t,n)||((e,r,t,n)=>{const o=T(r),{deep:c,names:s,checker:i,config:a,children:u}=o;if(i.setProperty&&i.setProperty(r,t,n,a,s),p("wrapSetPropertyValues",o)){if(!j(n)){const r=_(u,t);n=e(n,r?{info:r}:{deep:c,names:[...s,t],checker:i})}k(u,t,n)}return r[t]=n,!0})(e,r,t,n)})(N),I=(e=>(r,t,n)=>{const o=T(r),{names:c,config:s,checker:i}=o;i.arguments&&i.arguments(r,t,n,s,c),n=((e,r,t)=>{const n=T(r);if(p("wrapFunctionArguments",n)){const{length:r}=t;for(let o=0;o<r;o++)t[o]=v(e,n,String(o),t[o])}return t})(e,r,n);let a=r.apply(t,n);return i.returnValue&&i.returnValue(r,t,a,s,c),p("wrapFunctionReturnValues",o)&&(a=v(e,o,"returnValue",a)),a})(N);const $=(e,r)=>{const t=M(e,r),{deep:n,names:o,checker:c,config:s,children:i}=t;return Object.keys(e).forEach(r=>{const t=e[r];if(c.getProperty(e,r,t,s,o),S(t)){let e=_(i,r);e?$(t,{info:e}):(e=$(t,{deep:n,names:[...o,r],checker:c}),m(i,r,e))}}),R(e,t),t};r.getDefaultTypeChecker=s,r.setDefaultTypeChecker=(e=>{c=e}),r.PROXY_WRAP_FUNCTION_RETURN_VALUES="wrapFunctionReturnValues",r.PROXY_WRAP_FUNCTION_ARGUMENTS="wrapFunctionArguments",r.PROXY_WRAP_SET_PROPERTY_VALUES="wrapSetPropertyValues",r.PROXY_IGNORE_PROTOTYPE_METHODS="ignorePrototypeMethods",r.getDefaultProxyConfig=i,r.setProxyConfig=(e=>Object.assign(a,e)),r.getProxyConfig=(()=>Object.assign({},a)),r.create=N,r.createDeep=((e,r)=>e&&"object"==typeof e&&h()&&!j(e)?($(e,r),F(e)):e),r.ConsoleErrorReporter=l,r.ConsoleWarnReporter=((e,r,t,n)=>console.warn(u(e,r,t,n))),r.ThrowErrorReporter=((e,r,t,n)=>{throw new Error(u(e,r,t,n))}),r.getErrorReporter=g,r.setErrorReporter=(e=>{f=e}),r.isEnabled=h,r.setEnabled=((e=!0)=>{y=!!e}),r.getTargetInfo=T,r.setTargetInfo=R,r.hasTargetInfo=O,r.getTargetTypeChecker=(e=>{if(e){const r=e[d];return r&&r.checker||void 0}}),r.getTargetTypeCheckerConfig=(e=>{if(e){const r=e[d];return r&&r.config||void 0}}),r.mergeTargetInfo=b,r.getOriginalTarget=(e=>e&&e[C]||e),r.merge=((e,...r)=>{let t={};return h()&&(e||(e={info:T(r.find(e=>O(e))),deep:!1}),t=N(t,e)),Object.assign(t,...r)}),r.properties=((e,r,...t)=>{if(!h())return e;if(!S(e))throw new Error("Target must be a valid object.");if(Object.isFrozen(e)||Object.isSealed(e))throw new Error("Target object should not be sealed or frozen.");t.length||(t=Object.keys(e));const{length:n}=t;for(let o=0;o<n;o+=1){const n=t[o],{writable:c,get:s,set:i}=Object.getOwnPropertyDescriptor(e,n);if(s&&i||c){const t=e[n];S(t)&&!j(t)&&(e[n]=N(t,r))}}return e}),r.isTypeChecked=j,r.isValidTarget=S,r.default=N}));r(c);c.getDefaultTypeChecker,c.setDefaultTypeChecker,c.PROXY_WRAP_FUNCTION_RETURN_VALUES,c.PROXY_WRAP_FUNCTION_ARGUMENTS,c.PROXY_WRAP_SET_PROPERTY_VALUES,c.PROXY_IGNORE_PROTOTYPE_METHODS,c.getDefaultProxyConfig,c.setProxyConfig,c.getProxyConfig,c.create,c.createDeep,c.ConsoleErrorReporter,c.ConsoleWarnReporter,c.ThrowErrorReporter,c.getErrorReporter,c.setErrorReporter,c.isEnabled,c.setEnabled,c.getTargetInfo,c.setTargetInfo,c.hasTargetInfo,c.getTargetTypeChecker,c.getTargetTypeCheckerConfig,c.mergeTargetInfo,c.getOriginalTarget,c.merge,c.properties,c.isTypeChecked,c.isValidTarget;const s="(Arguments)",i="(ReturnValue)";function a(e){if(!(this instanceof a))return new a(e);this.value=e}function p(){return this.value}a.prototype.toString=p,a.prototype.valueOf=p,a.prototype[Symbol.toPrimitive]=p;const u=e=>e.reduce((e,r)=>r instanceof a?`${e}${r}`:String(parseInt(r,10))===r?`${e}[${r}]`:/^[a-z][\w$]*$/i.test(r)?e?`${e}.${r}`:r:`${e}["${r}"]`,""),l=(e,r,t,n,o,c)=>{if(!n)return!0;const s=r[t];if(s){if(s!==n)return o(e,u([...c,t]),s,n),!1}else r[t]=n;return!0},f=({types:e,errorReporter:r},t,n=[])=>{const c=t.types;for(const t in c)if(o(c,t)){const o=c[t],s=e[t];o&&s&&s!==o?r("(Merge)",u([...n,t]),s,o):e[t]=o}return{types:e,errorReporter:r}},g=e=>void 0===e?"":e instanceof Array?"array":typeof e,y=e=>{return function(r,t,n,o,c){const{types:s,errorReporter:i}=o,a=this.getTypeString(n);return l(e,s,t,a,i,c)}},h=y("(GetProperty)"),d=y("(SetProperty)");class P{constructor(){this.collectTypesOnInit=!0,this.getTypeString=g,this.mergeConfigs=f}init(e,r,t=null){let n={};return t?n=t:this.collectTypesOnInit&&Object.keys(e).forEach(r=>{n[r]=g(e[r])}),{types:n,errorReporter:r}}getProperty(e,r,t,n,o){return h.call(this,e,r,t,n,o)}setProperty(e,r,t,n,o){return d.call(this,e,r,t,n,o)}arguments(e,r,t,n,o){const{types:c,errorReporter:i}=n,{length:a}=t;let p=!0;for(let e=0;e<a;e++){const r=this.getTypeString(t[e]);p=l(s,c,String(e),r,i,o)&&p}return p}returnValue(e,r,t,n,o){const{types:c,errorReporter:s}=n,p=this.getTypeString(t);return l(i,c,a(i),p,s,o)}}var T=Object.freeze({MERGE:"(Merge)",ARGUMENTS:s,GET_PROPERTY:"(GetProperty)",RETURN_VALUE:i,SET_PROPERTY:"(SetProperty)",buildPath:u,AsIs:a,checkPrimitiveType:l,mergeConfigs:f,getTypeString:g,propertyCheckerFactory:y,PrimitiveTypeChecker:P,default:P}),R=T&&P||T,O=t(function(e,r){c.setDefaultTypeChecker(new R.PrimitiveTypeChecker),Object.assign(r,R,c)});e.default=O,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=primitive-type-checker.min.js.map
